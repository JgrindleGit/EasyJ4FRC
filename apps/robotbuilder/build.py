#!/usr/bin/python

import errno, glob, httplib, json, os, re, subprocess, sys, threading, urllib

HEADER = ('// Do not edit this file; automatically generated by build.py.\n'
          '"use strict";\n')

class Gen_compressed(threading.Thread):
  """Generate a JavaScript file that contains all of Blockly's core and all
  required parts of Closure, compiled together.
  Uses the Closure Compiler's online API.
  Runs in a separate thread.
  """
  def __init__(self):
    threading.Thread.__init__(self)

  def run(self):
    self.gen_blocks()


  def gen_blocks(self):
    target_filename = 'dist/easyj_blocks_compressed.js'
    # Define the parameters for the POST request.
    params = [
        ('compilation_level', 'SIMPLE_OPTIMIZATIONS'),
        ('output_format', 'json'),
        ('output_info', 'compiled_code'),
        ('output_info', 'warnings'),
        ('output_info', 'errors'),
        ('output_info', 'statistics'),
      ]

    # Read in all the source files.
    # Add Blockly.Blocks to be compatible with the compiler.
    params.append(('js_code', "goog.provide('Blockly.Blocks');"))
    filenames = glob.glob(os.path.join('blocks', 'local', '*.js'))
    filenames.extend(glob.glob(os.path.join('blocks', 'blockly', '*.js')))
    for filename in filenames:
      f = open(filename)
      params.append(('js_code', ''.join(f.readlines())))
      f.close()

    # Remove Blockly.Blocks to be compatible with Blockly.
    remove = "var Blockly={Blocks:{}};"
    self.do_compile(params, target_filename, filenames, remove)

    # @todo it would be nice if the ../../build.py was more like a library so
    # I didn't have to duplicate all of this code
  def do_compile(self, params, target_filename, filenames, remove):
    # Send the request to Google.
    headers = { "Content-type": "application/x-www-form-urlencoded" }
    conn = httplib.HTTPConnection('closure-compiler.appspot.com')
    conn.request('POST', '/compile', urllib.urlencode(params), headers)
    response = conn.getresponse()
    json_str = response.read()
    conn.close()

    # Parse the JSON response.
    json_data = json.loads(json_str)

    def file_lookup(name):
      if not name.startswith('Input_'):
        return '???'
      n = int(name[6:])
      return filenames[n]

    if json_data.has_key('serverErrors'):
      errors = json_data['serverErrors']
      for error in errors:
        print 'SERVER ERROR: %s' % target_filename
        print error['error']
    elif json_data.has_key('errors'):
      errors = json_data['errors']
      for error in errors:
        print('FATAL ERROR')
        print(error['error'])
        print('%s at line %d:' % (
            file_lookup(error['file']), error['lineno']))
        print(error['line'])
        print((' ' * error['charno']) + '^')
        sys.exit(1)
    else:
      if json_data.has_key('warnings'):
        warnings = json_data['warnings']
        for warning in warnings:
          print('WARNING')
          print(warning['warning'])
          print('%s at line %d:' % (
              file_lookup(warning['file']), warning['lineno']))
          print(warning['line'])
          print((' ' * warning['charno']) + '^')
        print()

      if not json_data.has_key('compiledCode'):
        print('FATAL ERROR: Compiler did not return compiledCode.')
        sys.exit(1)

      code = HEADER + '\n' + json_data['compiledCode']
      code = code.replace(remove, '')

      # Trim down Google's Apache licences.
      LICENSE = re.compile("""/\\*

 [\w ]+

 (Copyright \\d+ Google Inc.)
 https://blockly.googlecode.com/

 Licensed under the Apache License, Version 2.0 \(the "License"\);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
\\*/""")
      code = re.sub(LICENSE, r"\n// \1  Apache License 2.0", code)

      stats = json_data['statistics']
      original_b = stats['originalSize']
      compressed_b = stats['compressedSize']
      if original_b > 0 and compressed_b > 0:
        f = open(target_filename, 'w')
        f.write(code)
        f.close()

        original_kb = int(original_b / 1024 + 0.5)
        compressed_kb = int(compressed_b / 1024 + 0.5)
        ratio = int(float(compressed_b) / float(original_b) * 100 + 0.5)
        print('SUCCESS: ' + target_filename)
        print('Size changed from %d KB to %d KB (%d%%).' % (
            original_kb, compressed_kb, ratio))
      else:
        print 'UNKNOWN ERROR'

if __name__ == '__main__':
  Gen_compressed().start()